## 任务101：Flex首次尝试

**任务描述**

相信你学习过编译原理之后，一定是跃跃欲试，想要自己实现一个词法分析器，但是呢，别着急动手，要学会站在巨人的肩膀上。你是否发现，自己编写一大段重复或者类似的scanf和if语句来识别字符串十分麻烦？实际上，我们已经有了lex这个强大的工具。Lex是Lexical Compiler的缩写，是Unix环境下非常著名的工具，主要功能是生成一个词法分析器(scanner)的C源码，描述规则采用正则表达式(regular expression)。`Flex(The Fast Lexical Analyzer)`是GNU/Linux下的lex版本。

**相关知识**

为了完成本关任务，你需要掌握：

1. lex/flex词法描述文件的结构
2. 如何写一条规则。

`flex`是产生词法分析器`scanner`的工具。词法分析程序是识别文本中单词模式的源程序。`flex`读入描述词法分析规则的文件，该描述文件由`正规式`和`C代码`对（规则rules）构成。flex产生的输出是一个C文件：`lex.yy.c`，其中定义了关键过程`yylex()`。这个文件被编译、链接（加`-lfl`）后，产生词法分析的可执行程序。当执行时，它能分析出于对应`正规式`对应的单词；并在找到单词后，执行对应的`C代码`动作。

**lex/flex的语法结构**

lex/flex是通过处理其源文件来生词法和语法分析器的，源文件的扩展名为.l，其语法被分为三个部分：：

```c
 /* 预定义段 */
%{
%}
%%
/* 规则段 */
%%
/* 用户子程序段 */
```

三个段用 %% 进行分离。

1. **预定义段**，这一部分一般是一些声明及选项设置等。C 语言的注释、头文件包含等一般就放在`%{ %}` 之间，这一部分的内容会被直接复制到flex输出的`lex.yy.c`文件的开头部分；

2. **规则段**:包括一系列匹配模式和动作，模式一般使用正则表达式书写，动作部分为C代码：`模式1    {动作1(C代码)}`，在输入和模式 1 匹配的时候，执行动作部分的代码；

    | 符号  |  含义 |
    | ------------ | ------------ |
    | **\|**  | 或 |
    | [] | 括号中的字符取其一  |
    | **-**| a-z表示ascii码中介于a-z包括a、z的字符  |
    | \ | 转义（flex不能识别除字母外的字符）  |
    | * | 0或多个字符  |
    | ? | 0或1个字符  |
    | + | 1或多个字符  |
    | ^ | 除此之外的其余字符  |
    | **.** | 除\\n外的所有字符，等价于^\\n  |

3. **用户子程序段**：为 C 代码，也会被原样复制到`lex.yy.c`文件中。一般这里完成辅助函数的定义等，例如动作代码中使用到的函数。单独使用flex完成词法分析时，也可以将`main`函数放在这部分。

**如何写一条规则**

下面的输入，会定义一个分析器，当其遇到符号串`username`时，就将其替换成用户登录名，其中函数`getlogin()`需要在用户代码部分实现其定义。这里没有用括号标明`动作代码`，flex也能识别；当动作代码跨行，可以用括号对`{}`标明

```python
%%
username  printf("%s",getlogin());
```

`flex`中默认会将没有匹配的内容，直接拷贝到输出中，所以上面的代码会将输入内容拷贝到输出文件中，同时，将`username`的位置，替换成用户登录名。这里，只有一条规则：`username`是模式`pattern`，`printf`是对应的动作代码。而`%%`标出，从其后开始的内容，都属于规则部分。
通过一个简单的例子来学习如何写一条规则：

```c
/* 这里是定义段 */
%{
/* 这里的部分会被直接拷贝到生成的 .c 文件的开始部分，在这里可以包含需要使用的头文件，如 stdio.h
*/
#include <stdio.h>
#include <math.h>
%}
/* 下面是规则段 */
%%
/* 这里定义了四条规则，前面的部分是模式，处于一行的开始位置，后面的部分是动作。第一个模式是匹配连续的一个到多个字符，匹配到之后就将其打印出来。注意到 yytext，在输入匹配到该模式的时候，匹配的部分就存储在这个 yytext 里面，这里把它作为字符串直接输出就可以了；第二条规则的模式部分，就是匹配连续的一个或者多个数字，匹配到了之后，也是以字符串的形式输出；第三条规则的模式部分，就是匹配一个换行符了，并且匹配到之后就打印一个新行的信息；第四条规则的模式部分，是一个点。正则表达式里面这个也就是匹配任何除了 \n 之外的字符。因此，下面的规则就是，匹配到字符串，则将该字符串输出，匹配到连续数字，将其输出；匹配到换行符，打印一条信息；匹配到任何其他的字符，则直接忽略*/
[a-zA-Z]+       {printf("get string:%s\n", yytext);}
[0-9]+          {printf("get number:%s\n", yytext);}
\n              {printf("get new line\n"); }
.               { }
/* 下面是用户子程序段 */
%%
int yywrap() { return 1; }
int main(int argc, char** argv) {
    if (argc > 1) {
        if (!(yyin = fopen(argv[1], "r"))) {
            perror(argv[1]);
            return 1;
        }
    }
    while (yylex());
    return 0;
}
```

**编程要求**

阅读并参考Flex手册（flex 2.5.pdf）0.5的样例，调试运行，完成对输入文件的行数、字符数统计。注意，这个例子中，在规则部分开始前，直接用缩进格式，定义了变量`num_lines`，`num_chars`，在规则部分和用户代码部分，都能引用。

```python
int num_lines=0,num_chars=0;
%%
\n ++num_lines;++num_chars;
.  ++num_chars;
%%
int main()
{
 yylex();
 printf("Lines=%d,Chars=%d\n",num_lines,num_chars);
}
```

**编成环境搭建**

Ubuntu下
`$sudo apt update&&sudo apt install flex&&flex -h&&flex -V`

Compile the lex file and link it:
`$flex -o lex.yy.c mylex.l  && gcc -o mylex lex.yy.c`

**测试说明**

统计输入中的字符数（`不含换行符`）和行数

**测试输入**

```python
123456
abcdef
abcdef 
```

**预期输出**
`Lines=3,Chars=18`

开始你的任务吧，祝你成功！
