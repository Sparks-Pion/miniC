## 任务104：Flex词法规则补全（PL语言）

作为工科专业的同学，我们需要逐步培养处理复杂工程问题的能力，包括问题抽象、问题分解等等。一般现实中工程问题，往往需要分解成子问题,单独解决。
语言的词法、语法规则比较多，如果想一次全部解决，往往遇到的问题较多，慢慢就失去了信心。可以根据**语言单词可以分成不同类别分解，不同类别的单词，分阶段构造识别程序；用对应的测试样例进行测试，**这样循序渐进，便于模块化编程。

**任务描述**

利用flex工具生成PL语言的词法分析器，**要求输入PL语言源程序文件，输出单词序列tokens，包括每一个单词及其种别枚举值，每行一个单词**。

**相关知识**

为了完成本关任务，你需要掌握：flex的语法和使用规则。前面关卡中简略的介绍flex的相关知识，但没有涉及全部细节，在实验中，如果遇到其他问题，需要深入探究flex工作机制的，就需要参考flex2.5手册。

**编程要求**

请你根据提示，补充代码，设计识别PL语言单词符号的词法分析器。识别输出单词及中别枚举值。

`PL`语言单词符号及其种别值
![ PL ](../resource/1.jpg "PL" )
注意，这里还有一个类别`ERROR`，包括不是出现在字符串中的非法字符，`~!@#$%^&_\` 当词法分析器读到非法字符时，应该输出`ERROR`作为种别值。

识别PL单词的状态图（编译原理课程中的DFA/NFA在flex中应用后，自动完成了词法分析程序的构造，这个方法同学们可以借鉴）
![ DFA ](../resource/2.png "DFA" )

**测试说明**

平台会对你编写的代码进行测试：

**测试输入**

平台会对你编写的代码进行测试：
一共有5个测试集。

测试输入1：`case0.in`
这个测试集主要测试对算术运算符的识别。
需要完成的种别有：`IDENT，INTCON，PLUS，MINUS，TIMES，DIVSYM，BECOME`。

测试输入2：`case1.in`
这个测试集主要测试对字符常量的识别。
需要完成的种别有：`CHARCON`。

测试输入3：`case2.in`
这个测试集主要测试对比较运算符的识别。
需要完成的种别有：`IDENT，EQL，NEQ，LSS，LEQ，GTR，GEQ`。

测试输入4：`case3.in`
这个测试集是一个完整PL源程序。
需要完成的种别有：所有PL可以识别的种别。

测试输入5：`case4.in`
这个测试集是一个完整PL源程序中间插入了非法字符，需要将其识别出来。
需要完成的种别有：所有PL可以识别的`种别+ERROR`。
每种语言，可以有不同的词法规则，具体需要查阅该语言的手册，然后编写词法规则，进行分组样例测试进行验证。当词法分析程序正确识别所有类型的单词后，就可以进行语法分析了。

**预期输出**

单词及种别

开始你的任务吧，祝你成功！

——————————————————————

**需要掌握的前序知识**

**lex/flex的语法结构**

lex/flex是通过处理其源文件来生词法和语法分析器的，源文件的扩展名为.l，其语法被分为三个部分：：

```c
 /* 定义段 */
%{
%}
%%
/* 规则段 */
%%
/* 用户子程序段 */
```

三个段用 %% 进行分离。

1. 定义段，这一部分一般是一些声明及选项设置等。C 语言的注释、头文件包含等一般就放在 %{ %} 之间，这一部分的内容会被直接复制到输出文件的开头部分；

2. 规则段为一系列匹配模式和动作，模式一般使用正则表达式书写，动作部分为C代码：`模式1    {动作1(C代码)}`，在输入和模式 1 匹配的时候，执行动作部分的代码；

    | 符号  |  含义 |
    | ------------ | ------------ |
    | **\|**  | 或 |
    | [] | 括号中的字符取其一  |
    | **-**| a-z表示ascii码中介于a-z包括a、z的字符  |
    | \ | 转义（flex不能识别除字母外的字符）  |
    | * | 0或多个字符  |
    | ? | 0或1个字符  |
    | + | 1或多个字符  |
    | ^ | 除此之外的其余字符  |
    | **.** | 除\\n外的所有字符，等价于^\\n  |

3. 用户子程序段，这里为 C 代码，会被原样复制到输出文件中，一般这里定义一些辅助函数等，如动作代码中使用到的辅助函数。

**如何写一条规则**

下面通过一个简单的例子来学习如何写一条规则：

```c
 /* 这里是定义段 */
%{
/* 这里的部分会被直接拷贝到生成的 .c 文件的开始部分，在这里可以包含需要使用的头文件，如 stdio.h
*/
#include <stdio.h>
%}
/* 下面是规则段 */
%%
/* 这里定义了四条规则，前面的部分是模式，处于一行的开始位置，后面的部分是动作。第一个模式是匹配连续的一个到多个字符，匹配到之后就将其打印出来。注意到 yytext，在输入匹配到该模式的时候，匹配的部分就存储在这个 yytext 里面，这里把它作为字符串直接输出就可以了；第二条规则的模式部分，就是匹配连续的一个或者多个数字，匹配到了之后，也是以字符串的形式输出；第三条规则的模式部分，就是匹配一个换行符了，并且匹配到之后就打印一个新行的信息；第四条规则的模式部分，是一个点。正则表达式里面这个也就是匹配任何除了 \n 之外的字符。因此，下面的规则就是，匹配到字符串，则将该字符串输出，匹配到连续数字，将其输出；匹配到换行符，打印一条信息；匹配到任何其他的字符，则直接忽略*/
[a-zA-Z]+       {printf("get string:%s\n", yytext);}
[0-9]+          {printf("get number:%s\n", yytext);}
\n              {printf("get new line\n"); }
.               { }
/* 下面是用户子程序段 */
%%
int yywrap() { return 1; }
int main(int argc, char** argv) {
    if (argc > 1) {
        if (!(yyin = fopen(argv[1], "r"))) {
            perror(argv[1]);
            return 1;
        }
    }
    while (yylex());
    return 0;
}
```

